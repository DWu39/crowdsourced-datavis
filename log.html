<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <script src="d3.v3.min.js"></script>
    <style>
        .user-name, .msg-length {
            font-family: 'Helvetica';
            font-size: 14px;
        }

        div {
            display: inline-block;
            border: 1px solid #f3f3f3;
        }

        #display {
            position: fixed;
            margin: 30px;
            width: 640px;
            height: 500px;
            font-family: 'Helvetica';
            font-size: 14px;
        }
    </style>
</head>
<body>
    <!-- The SVG element will go in here -->
    <div id='canvas'></div>

    <div id='display'></div>

    <script>
        // ------------- CONSTRUCTORS ------------- //

        // create a new message object
        function Message(event) {

        }


        // ------------- GLOBAL PARAMETERS ------------- //
        var buffer_size = 5; // number of messages to display per interval
        var padding = 30,
            width = 720,
            height = 800,
            totalBarHeight = 0;

        var barWidth = 30,
            barSpacing = 48;

        var offset = 150; // to provide space for names


        // ------------- GLOBAL DATA ------------- //
        var dataset,
            model = []; // viewmodel, hold current displayed set of messages

        var plot = d3.select('#canvas') // element to append messages
                          .append('svg')
                          .attr('width', width).attr('height', height);

        var users = {} // users to colors


        // ------------- GRAPH PARAMETERS ------------- //
        var color = d3.scale.category20(); // color picker

        var longestMsgLength = null; // longest message in viewmodel

        var xScale = d3.scale.linear()
                       .domain([0, longestMsgLength])
                       .range([padding, width - padding - offset]);


        // ------------- DISPLAY PARAMETERS ------------- //
        var display = d3.select('#display');


        // ------------- LOAD DATA ------------- //
        d3.csv('communication.csv', function(data) {

            // filter for only messages
            dataset = data.filter(function(d) {
                var message = JSON.parse(d['message']);
                return message['type'] === 'comment';
            });

            // convert dataset to all Message objects
            dataset = dataset.map(function(d) {
                d['message'] = JSON.parse(d['message']);
                return d;
            })

            console.log(dataset[0]);
            // return;


            // ------------- STREAM MESSAGES ------------- //
            var stream = setInterval(function() {

                var nextBatch = dataset.slice(0, Math.floor(buffer_size*Math.random()) + 1);

                // add new messages to index
                // TODO: don't actually need to store messages themselves?
                nextBatch.forEach(function(d) {
                    if (users[d['userId']]) {
                        users[d['userId']]['messages'].push(d);
                    // new user must give a color too
                    } else {
                        users[d['userId']] = {
                            color: color(Math.random()),
                            messages: [d]
                        }
                    }
                })

                // check if we need to rescale
                var maxInNextBatch = d3.max(nextBatch, function(d) {
                    return d['message']['comment']['text'].length;
                });

                // adjust scale, axes, and bars
                if (maxInNextBatch > longestMsgLength) {
                    console.log(maxInNextBatch);
                    longestMsgLength = maxInNextBatch;
                    xScale.domain([0, longestMsgLength]);
                    console.log(xScale(maxInNextBatch));
                }

                // adjust viewmodel and remove new messages from dataset
                model = model.concat(nextBatch);
                dataset = dataset.slice(nextBatch.length);

                // expand height of svg to account for new elements
                totalBarHeight += nextBatch.length*(barSpacing);
                if (totalBarHeight > height) {
                    plot.attr('height', totalBarHeight);
                }


                // ------------- ADD ELEMENTS ------------- //

                // TODO: combine rect and text into a g?
                // append new message bars to plot
                var rects = plot.selectAll('rect').data(model);

                rects.enter()
                     .append('rect')
                     .style('fill', 'grey')
                     .attr('x', offset + xScale(0))
                     .attr('y', function(d, i) { return i*barSpacing; })
                     .attr('height', barWidth)
                     .on('mouseover', function(d) { console.log(d['userId']); });

                // update + enter: normalize bar lengths
                rects.transition().duration(750)
                    .attr('width', function(d) {
                        return xScale(d['message']['comment']['text'].length);
                    });

                // append userIds before message bars
                var userNames = plot.selectAll('text.user-name').data(model);

                userNames.enter()
                    .append('text')
                        .text(function(d) { return d['userId'] })
                        .attr('x', padding)
                        .attr('y', function(d, i) { return i*barSpacing + barSpacing/2; })
                        .attr('text-anchor', 'left')
                        .attr('fill', 'grey')
                        .classed('user-name', true);

                // append message lengths to end of bars
                var msgLengths = plot.selectAll('text.msg-length').data(model);

                msgLengths.enter()
                    .append('text')
                        .text(function(d) { return d['message']['comment']['text'].length; })
                        .attr('y', function(d, i) { return i*barSpacing + barSpacing/2; })
                        .attr('text-anchor', 'right')
                        .attr('fill', 'white')
                        .classed('msg-length', true);

                // update + enter: adjust number placement as scale changes
                msgLengths.transition().duration(750)
                    .attr('x', function(d) {
                        return offset + xScale(d['message']['comment']['text'].length);
                    });

                // bind events to bars
                rects.on('mouseover', function(thisData) {
                    // highlight other bars with same userId
                    rects.filter(function(d) { return d['userId'] === thisData['userId']; })
                         .style('fill', users[thisData['userId']]['color']);
                    // highlight names as well
                    userNames.filter(function(d) { return d['userId'] === thisData['userId']; })
                         .style('fill', users[thisData['userId']]['color']);

                    // update display
                    display.text(function() { return thisData['message']['comment']['text']; })
                });

                rects.on('mouseout', function(thisData) {
                    rects.filter(function(d) { return d['userId'] === thisData['userId']; })
                         .style('fill', 'grey');
                    userNames.filter(function(d) { return d['userId'] === thisData['userId']; })
                         .style('fill', 'grey');
                })


                // terminate stream if no more messages
                if (!(dataset.length > 0)) {
                    clearInterval(stream);
                    console.log('no more messages!');
                }
            }, 2000);
        });
    </script>
</body>
</html>