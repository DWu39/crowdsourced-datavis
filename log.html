<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <script src="d3.v3.min.js"></script>
    <style>
        rect.highlight {
            fill: blue;
        }

        #canvas {
            overflow: auto;
        }
    </style>
</head>
<body>
    <!-- The SVG element will go in here -->
    <div id="canvas"></div>

    <script>
        // ------------- GLOBAL PARAMETERS ------------- //
        var buffer_size = 5; // number of messages to display per interval
        var padding = 30,
            width = 720,
            height = 800,
            totalBarHeight = 0;

        var barWidth = 30,
            barSpacing = 48;

        var offset = 150; // to provide space for names


        // ------------- GLOBAL DATA ------------- //
        var dataset,
            model = []; // viewmodel, hold current displayed set of messages

        var plot = d3.select('#canvas') // element to append messages
                          .append('svg')
                          .attr('width', width).attr('height', height);

        var users = {} // index of messages: [userId] -> array of messages


        // ------------- GRAPH PARAMETERS ------------- //
        // TODO: find better way to initialize graph axes
        var longestMsgLength = 5; // longest message in dataset

        var xScale = d3.scale.linear()
                       .domain([0, longestMsgLength])
                       .range([padding, width - padding]);

        var xAxis = d3.svg.axis().orient('bottom').scale(xScale);

        var color = d3.scale.category20(); // color picker

        // plot.append("g")
        //          .attr("class", "x-axis")
        //          .attr("transform", "translate(0," + (height - padding) + ")")
        //          .call(xAxis);


        // ------------- LOAD DATA ------------- //
        d3.csv('communication.csv', function(data) {

            // data = data.splice(0, 140);

            // filter for only messages
            dataset = data.filter(function(d) {
                var message = JSON.parse(d['message']);
                return message['type'] === 'comment';
            });

            // convert the messages in dataset to json
            dataset = dataset.map(function(d) {
                d['message'] = JSON.parse(d['message']);
                return d;
            })


            // ------------- STREAM MESSAGES ------------- //
            var stream = setInterval(function() {

                var nextBatch = dataset.slice(0, Math.floor(buffer_size*Math.random()) + 1);

                // add new messages to index
                nextBatch.forEach(function(d) {
                    if (users[d['userId']]) {
                        users[d['userId']]['messages'].push(d['message']['comment']['text']);
                    // new user must give a color too
                    } else {
                        users[d['userId']] = {
                            color: color(Math.random()),
                            messages: [d['message']['comment']['text']]
                        }
                    }
                })

                // check if we need to rescale
                var maxInNextBatch = d3.max(nextBatch, function(d) {
                    return d['message']['comment']['text'].length;
                });

                // adjust scale, axes, and bars
                if (maxInNextBatch > longestMsgLength) {
                    longestMsgLength = maxInNextBatch;
                    xScale.domain([0, longestMsgLength]);
                    xAxis = d3.svg.axis().orient('bottom').scale(xScale);
                    plot.select('.x-axis')
                             .transition().duration(1000).ease("sin-in-out")
                             .call(xAxis);
                }

                model = model.concat(nextBatch);
                dataset = dataset.slice(nextBatch.length);

                // expand height of svg to account for new elements
                totalBarHeight += nextBatch.length*(barSpacing);
                if (totalBarHeight > height) {
                    plot.attr('height', totalBarHeight);
                }

                // join new data
                var rects = plot.selectAll('rect').data(model);

                // TODO: update old data
                // rects.style('fill', 'red');

                // TODO: combine rect and text into a g?
                // append new messages to plot
                rects.enter()
                    .append('rect')
                    .style('fill', 'grey')
                    .attr('x', offset + xScale(0))
                    .attr('y', function(d, i) { return i*barSpacing; })
                    .attr('height', barWidth)
                    .attr('width', function(d) {
                        // TODO: Why is this going all the way to the end?
                        return xScale(d['message']['comment']['text'].length);
                    })
                    // .attr('data-user', function(d) { return d['userId']; })
                    .attr('fill-opacity', 0)
                    .transition().duration(1000).attr('fill-opacity', 1);

                // include userIds with messages
                plot.selectAll('text').data(model).enter()
                    .append('text')
                    .text(function(d) { return d['userId'] })
                    .attr('x', padding)
                    .attr('y', function(d, i) { return i*barSpacing + barSpacing/2; })
                    .attr('text-anchor', 'left')
                    .attr('font-family', 'Helvetica')
                    .attr('font-size', '14px')
                    .attr('fill-opacity', 0)
                    .transition().duration(1000).attr('fill-opacity', 1);

                // include message lengths with each bar
                plot.selectAll('text').data(model).enter()
                    .append('text')
                    .text(function(d) { return d['message']['comment']['text'].length; })
                    .attr('x', function(d) { return xScale(d['message']['comment']['text'].length); })
                    .attr('y', function(d, i) { return i*barSpacing + barSpacing/2; })
                    .attr('text-anchor', 'left')
                    .attr('font-family', 'Helvetica')
                    .attr('font-size', '14px')
                    .attr('fill-opacity', 0)
                    .transition().duration(1000).attr('fill-opacity', 1);

                rects.on('mouseover', function(thisData) {
                    rects.filter(function(d) { return d['userId'] === thisData['userId']; })
                         .style('fill', function() { return users[thisData['userId']]['color']; });
                });

                rects.on('mouseout', function(thisData) {
                    rects.filter(function(d) { return d['userId'] === thisData['userId']; })
                         .style('fill', 'grey');
                })

                // terminate stream if no more messages
                if (!(dataset.length > 0)) {
                    clearInterval(stream);
                    console.log('no more messages!');
                }
            },1000);
        });
    </script>
</body>
</html>