<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <script src="js/lib/d3.v3.min.js"></script>
    <script src="js/generateData.js"></script>
    <link rel="stylesheet" type="text/css" href="css/styles.css">

    <style>
        line { stroke: #fff; }
        * { font-size: 10px; }
    </style>
</head>
<body>
    <div id='matrix'></div>
    <input id='timeline' type='range' min='0'></input>

    <script>
        // ---------- CLASSES/HELPERS ---------- //
        function User(id, loc, name, role) {
            this.id = id;
            this.location = loc;
            this.name = name;
            this.role = role;
            this.actions = [];
        };

        User.prototype.addAction = function(action) { this.actions.push(action); }

        /**
        * Constructs a matrix object that can be rendered by view.
        * requires: [Object] viewModel to render
        *           [Array] an ordering of user ids for the view to render
        */
        function Matrix(viewModel, ordering) {
            this.users = viewModel.users;
            this.links = viewModel.links;
            this.ordering = ordering;

            var matrix = [],
                n = controller.getNumUsers();

            // initialize matrix from top row to bottom row
            for (var i=0; i<n; i++)
                // look up on global allUsers
                // d3.range(m)
                matrix[i] = d3.range(n).map(function(j) { return {x: j, y: i, z: 0}; });

            viewModel.links.forEach(function(link) {
                var source = link.source.id,
                    target = link.target.id;

                matrix[source][target].z += link.value; // user in row i affects users in columns
                if (source !== target) matrix[source][source].z += link.value; // reflexive property
            });

            this.matrix = matrix;
        }

        /**
        * Creates Link objects given a set of users and their actions.
        * Can use Jaccard, Euclidean distance
        * requires: [Object] users: user id --> User object
        *           [string] similarity: which sim function to use in switch case
        */
        function computeLinks(users, similarity) {
            var links = [];

            for (var u in users) {
                users[u].actions.forEach(function(action) {
                    var val = action.affect;

                    links.push({
                        source: users[u],
                        target: randomProperty(users),
                        value: val
                    });
                });
            }
            return links;
        }

        // grab random property of object
        var randomProperty = function (obj) {
            var keys = Object.keys(obj)
            return obj[keys[ keys.length * Math.random() << 0]]; // shift bit to floor
        };


        // ---------- MVC ---------- //
        var model = {
            // starting up/clearing model with fresh data
            init: function() {
                this.store = []; // stores all datapoints

                this.users = []; // list of user ids

                this.viewModel = { // holds the current data being shown in view
                    users: {}, // user id to User objects and their actions
                    links: []
                };
            },

            // Reads more data into model.
            // requires: list of data points
            storeInModel: function(data) {
                // store each data point and list of user ids in data
                for (var i=0; i<data.length; i++) {
                    var d = data[i];
                    this.store.push(d);
                    if (this.users.indexOf(d.id) === -1)
                        this.users.push(d.id);
                };
            },

            // store new data in viewModel
            // requires: list of data points
            storeInViewModel: function(data) {
                // construct set of user objects
                for (var i=0; i<data.length; i++) {
                    var d = data[i];

                    if (typeof this.viewModel.users[d.id] === 'undefined')
                        this.viewModel.users[d.id] = new User(d.id, d.location, d.name, d.role);

                    this.viewModel.users[d.id].addAction(d.action);
                };
                this.viewModel.links = computeLinks(this.viewModel.users);
            },
        };

        var controller = {
            init: function(ordering) {
                model.init();
                view.init();
                this.getOrdering = ordering ? ordering : this.orderByName; // order by name by default
            },

            // load more data into model
            storeModel: function(data) { model.storeInModel(data); },

            // set the data to be displayed in view model
            storeViewModel: function(data) {
                var data = typeof data === 'undefined' ? model.store : data; // load all data by default
                model.storeInViewModel(data);
            },

            // feed current viewModel into view
            renderView: function() {
                var ordering = this.getOrdering(model.viewModel.users);
                var matrix = new Matrix(model.viewModel, ordering);
                view.render(matrix);
            },

            getNumUsers: function() { return model.users.length; },

            orderById: function(users) {
                if (users) {
                    return d3.range(users.length).sort(function(a, b) {
                        return d3.ascending(users[a].id, users[b].id);
                    });
                }
                return []
            },

            orderByName: function(users) {
                if (users) {
                    return d3.range(users.length).sort(function(a, b) {
                        return d3.ascending(users[a].name, users[b].name);
                    });
                }
                return []
            },

            setOrdering: function(ordering) { this.getOrdering = ordering; }
        };

        var view = {
            // create new canvas for matrix to be drawn in
            init: function() {
                this.margin = {top: 100, right: 0, bottom: 0, left: 100};
                this.width = 480;
                this.height = 480;
            },

            // draw a new matrix
            render: function(matrix) {
                // remove all previous matrix svgs and create new one
                d3.select('#matrix svg').remove();
                var svg = d3.select('#matrix').append('svg')
                    .attr("width", this.width + this.margin.left + this.margin.right)
                    .attr("height", this.height + this.margin.top + this.margin.bottom)
                    .style("margin-left", this.margin.left + "px")
                    .append("g")
                    .attr("transform", "translate(" + this.margin.left + "," + this.margin.top + ")");

                var x = d3.scale.ordinal() // scale for the position of user
                          .domain(matrix.ordering)
                          .rangeBands([0, this.width]);

                var z = d3.scale.linear() // scale for the link strength
                          .domain([0, d3.max(matrix.links, function(link) { return link.value; })])
                          .range(['white', 'red']);

                // draw matrix rows
                var row = svg.selectAll(".row")
                    .data(matrix.matrix).enter()
                    .append("g")
                    .attr("class", "row")
                    .attr("transform", function(d, i) { return "translate(0," + x(i) + ")"; })
                    .each(row);

                row.append("line").attr("x2", this.width);

                row.append("text")
                    .attr("x", -6)
                    .attr("y", x.rangeBand() / 2)
                    .attr("dy", ".32em")
                    .attr("text-anchor", "end")
                    .text(function(d, i) { return matrix.users[i].name; });

                // fill in row with data and add hover effects
                function row(row) {
                    var cell = d3.select(this).selectAll(".cell")
                        .data(row.filter(function(d) { return d.z; }))
                        .data(row)
                        .enter().append("rect")
                            .attr("class", "cell")
                            .attr("x", function(d) { return x(d.x); })
                            .attr("width", x.rangeBand())
                            .attr("height", x.rangeBand())
                            .style('fill', function(d) { return z(d.z); })
                            .on("mouseover", mouseover)
                            .on("mouseout", mouseout);
                }

                //draw matrix columns
                var column = svg.selectAll(".column")
                    .data(matrix.matrix).enter()
                    .append("g")
                    .attr("class", "column")
                    .attr("transform", function(d, i) { return "translate(" + x(i) + ")rotate(-90)"; });

                column.append("line").attr("x1", -this.width);

                column.append("text")
                      .attr("x", 6)
                      .attr("y", x.rangeBand() / 2)
                      .attr("dy", ".32em")
                      .attr("text-anchor", "start")
                      .text(function(d, i) { return matrix.users[i].name; });

                function mouseover(p) {
                    d3.selectAll(".row text").classed("active", function(d, i) { return i == p.y; });
                    d3.selectAll(".column text").classed("active", function(d, i) { return i == p.x; });
                    d3.selectAll('.active').transition().style('font-size', 15);
                }

                function mouseout() {
                    d3.selectAll('.active').transition().style('font-size', 10);
                    d3.selectAll("text").classed("active", false);
                }
            },
        };

        // ---------- FILTERS ---------- //
        (function() {
            var prototype = d3.selection.prototype; // add new methods to the d3 selection prototype

            /**
            * param data - d3 selection of data
            * param str - string to filter by, can also be array of strings
            * param prop - property holding the string
            */
            var filterByString = function(data, str, prop) {
                return data.filter(function(d) {
                    if (typeof str === 'string') return d.action[prop] === str;
                    else return str.indexOf(d.action[prop]) !== -1;
                });
            };

            // TODO: more accurate word count, e.g. disregarding special characters
            var countWords = function(text) { return text.split(' ').length; };

            /**
            * param s - start time
            * param t - end time
            * set s or t to null if you want to disregard
            */
            prototype.slice = function(s, t) {
                if (s > t) return d3.select([]);

                var res = this;
                if (typeof s === 'number' && s >= 0)
                    res = res.filter(function(d) { return d.action.date >= s; });

                if (typeof t === 'number' && t >= 0)
                    res = res.filter(function(d) { return d.action.date <= t; });

                return res;
            };

            /** TODO: not sure if storing in arrays works with D3
            * param len - length of time block
            * param n - first n events per block (optional)
            */
            prototype.block = function(len, n) {
                var blocks = [],
                    curr = [],
                    time = len,
                    data = this.sort(function(a, b) {
                        return d3.ascending(a.action.date, b.action.date);
                    });

                // split data into blocks
                data.each(function(d) {
                    if (d.action.date <= time) {
                        if (typeof n === 'undefined') curr.push(d);
                        else if (curr.length < n) curr.push(d);
                    } else {
                        blocks.push(curr);
                        // shift time block until current event fits
                        while (d.action.date > time) time += len;
                        curr = [d];
                    }
                });
                blocks.push(curr);
                return blocks;
            };

            prototype.filterByRole = function(role) { return filterByString(this, role, 'role'); };

            prototype.filterByLocation = function(loc) { return filterByString(this, loc, 'location'); };

            prototype.filterByText = function(text) {
                var re = new RegExp(text);
                return this.filter(function(d) { return d.action.text.search(re) !== -1; });
            };

            /**
            * param lo - min count
            * param hi - max count
            * set lo or hi to null if you want to disregard
            */
            prototype.filterByWordCount = function(lo, hi) {
                if (lo > hi) return d3.select([]); //TODO: how to return an empty selection?

                var res = this;
                if (typeof lo === 'number' && lo >= 0)
                    res = res.filter(function(d) { return countWords(d.action.text) >= lo; });

                if (typeof hi === 'number' && hi >= 0)
                    res = res.filter(function(d) { return countWords(d.action.text) <= hi; });

                return res;
            };

            /**
            * param id - integer or aray of integers
            */
            prototype.filterById = function(id) {
                return this.filter(function(d) {
                    if (typeof id === 'number') return d.id === id;
                    else return id.indexOf(d.id) !== -1;
                });
            }
        })();


        // ----------- SORTS ----------- //
       (function(){
            var prototype = d3.selection.prototype;

            /**
            * param data - javascript array of objects
            * param prop - object property
            * param asc - ascending sorting or not, true by default
            */
            var sortByString = function(data, prop, asc) {
                var asc = typeof asc !== 'undefined' ? asc : true,
                    f = function(a, b) {
                        if (a.action[prop] > b.action[prop]) return asc ? 1 : -1;
                        if (a.action[prop] < b.action[prop]) return asc ? -1 : 1;
                        else return 0;
                    };
                return data.sort(f);
            };

            prototype.sortByName = function(asc) {
                asc = typeof asc !== 'undefined' ? asc : true;
                return sortByString(this, 'name', asc);
            };

            prototype.sortByLocation = function(asc) {
                asc = typeof asc !== 'undefined' ? asc : true;
                return sortByString(this, 'location', asc);
            };

            prototype.sortByTime = function(asc) {
                var asc = typeof asc !== 'undefined' ? asc : true;
                    f = function(a, b) { return a.action.date - b.action.date; };
                return data.sort(f);
            };
        })();


        // ----------- TIMELINE ----------- //
        function renderTimeline(data, defaultLength) {
            // sort data by time
            var data = data.sort(function(a, b) { return a.action.date - b.action.date; });

            var time_beg = data[0].action.date,
                time_end = data[data.length - 1].action.date,
                numSlices = Math.floor(( time_end - time_beg)/defaultLength);

            var slider = d3.select('#timeline').attr('max', numSlices);

            slider.on('input', function() {
                var sliceStart = time_beg + (parseInt(slider.node().value) * defaultLength),
                    sliceEnd = sliceStart + defaultLength;

                var slice = data
                .filter(function(d) { return d.action.date >= sliceStart && d.action.date < sliceEnd; })
                .sort(function(a, b) { return a.action.date - b.action.date; });

                // store in view model
                controller.setViewModel(slice);
                controller.renderView();
            });
        };


        // ---------- INITIALIZE ---------- //
        // set up random data
        generate.setNumUsers(5);
        generate.setNumObservations(1);
        var data = generate.generateData(false);

        // store all data in model and all data in view model
        controller.init();
        controller.storeModel(data);
        controller.storeViewModel(data);

        // render martrix
        controller.renderView();

        // init timeline
        renderTimeline(data, 100000);
    </script>
</body>
</html>



