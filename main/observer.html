<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <script src="js/d3.v3.min.js"></script>
    <script src="/socket.io/socket.io.js"></script>
    <link rel="stylesheet" type="text/css" href="css/styles.css">

    <style>
        .background {
            fill: #eee;
        }

        line {
            stroke: #fff;
        }

        text.active {
            fill: red;
        }

        *{
            font-size: 10px;
        }
    </style>
</head>
<body>
    <div id='matrix'></div>
    <!-- <div id='timeline'></div> -->

    <script>
        // ---------- SOCKET.IO and EVENTS ---------- //
        var io = io();

        // TODO: get all other sockets and initialize model
        io.emit('observerConnect', function(data) {
            // store data in model and initialize matrix
        });

        // TODO: receive a draw event
        io.on('drawCircle', function(data) {
            console.log(data);
            // update the model
            // update the matrix
        });

        // TODO: catch new connections
        io.on('newConnection', function(conn) {
            console.log(conn);
        });


        // ---------- CLASSES ---------- //
        function User(data) {
            try {
                if (!data.id) throw 'missing id';
                if (!data.name) throw 'missing name';

                this.id = data.id;
                this.name = data.name;
                this.messages = [];
                this.value = 0;
            }
            catch (err) {
                alert('could not create user because of ' + err);
            }
        }

        User.prototype.addMessage = function(text, timestamp) {
            this.messages.append(new Message(text, timestamp));
        };

        function Message(text, timestamp) {
            this.text = text;
            this.timestamp = timestamp;
        }


        // ---------- HOLD DATA ---------- //
        var model = {
            init: function() {
                this.users = {};
                // links is a nested object representing an adjacency list
                // i.e. links[id] = {id2: value, id10: value}
                this.links = {};
            },

            addUser: function(data) {
                var user = new User(data);
                this.users[user.id] = user;
            },

            addMessage: function(id, message, timestamp) {
                try {
                    if (!this.users[id]) throw 'user id bad';
                    this.users[id].addMessage(message, timestamp);
                }
                catch (err) {
                    alert('could not add message because ' + err);
                }
            },

            addLink: function(src, targets, value) {
                value = typeof a !== 'undefined' ? a : 1;

                var links = this.links[src] ? this.links[src] : {};

                targets.forEach(function(target) {
                    if (links.hasOwnProperty(target)) links[target] += value;
                    else links[target] = value;
                });
            }
        }

        var matrix = {
            init: function(width) {
                width = typeof width !== 'undefined' ? width : 720;

                this.matrix = [];
                this.ordering = nameOrdering;
                this.x = d3.scale.ordinal().rangeBands([0, width]); // for the position of user
                this.z = d3.scale.linear().domain([0, 4]).clamp(true); // for the link strength, only 5 levels
                this.c = d3.scale.category10().domain(d3.range(10)); // for the cluster colors
            },

            setOrdering: function(ordering) {
                if this.hasOwnProperty(ordering) this.ordering = ordering;
                else console.log('ordering not found');
            }

            nameOrdering: function() {
                var obj = model.users,
                    users = Object.keys(obj).map(function(key) { return obj[key]; });

                return d3.range(this.matrix.length).sort(function(a, b) {
                    return d3.ascending(users[a].name, users[b].name);
                });
            },

            // insert new row for a user in the right location
            addUser: function(user) {
                if (!user.id in model.users) {
                    console.log('user does not exist');

                } else {
                    var ordering = this.ordering();

                    var matrix = this.matrix,
                        n = matrix.length;
                    // append new column to old rows
                    matrix.map(function(row, i) { row.push({x: n, y: i, z: 0 }); });
                    // create new row
                    matrix[n] = d3.range(n+1).map(function(j) { return {x: j, y: n, z: 0 }; });
                }
            },

            // return index corresponding to id
            getIndex: function(id) {
                matrix[0].forEach(function(col, i) {
                    if (col.id == id) return i;
                });
                return null;
            }

            // create new link or add value to existing link
            newLink: function(src, target, value) {
                var srcIndex = getIndex(src),
                    targetIndex = getIndex(target);

                if (matrix[srcIndex][targetIndex] > 0) {
                    matrix[srcIndex][targetIndex] += value;
                } else {
                    matrix[srcIndex][targetIndex] = value;
                }
            }
        }


        function createMatrix(data) {

            // ---------- MATRIX DISPLAY ---------- //
            var margin = {top: 80, right: 0, bottom: 10, left: 80},
                width = 720,
                height = 720;

            var svg = d3.select('#matrix').append('svg')
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
                .style("margin-left", margin.left + "px")
                .append("g")
                .attr("transform", "translate(" + margin.left + "," + margin.top + ")");


            // ---------- SCALES ---------- //
            var x = d3.scale.ordinal().rangeBands([0, width]), // for the position of user
                z = d3.scale.linear().domain([0, 4]).clamp(true), // for the link strength, only 5 levels
                c = d3.scale.category10().domain(d3.range(10)); // for the cluster colors

            // to hold the data
            var matrix = [],
                users = data.users,
                links = data.links,
                n = data.users.length;

            // initialize matrix
            users.forEach(function(user, i) {
                matrix[i] = d3.range(n).map(function(j) { return {x: j, y: i, z: 0}; });
            });

            links.forEach(function(link) {
                matrix[link.source][link.target].z += link.value; // bottom left triangle
                matrix[link.target][link.source].z += link.value; // top right triangle
                matrix[link.source][link.source].z += link.value; // node to itself
                matrix[link.target][link.target].z += link.value; // node to itself
                users[link.source].count += link.value;
                users[link.target].count += link.value;
            })

            // ordering of the elements in the matrix
            var nameOrdering = d3.range(n).sort(function(a, b) {
                return d3.ascending(users[a].name, users[b].name);
            })

            x.domain(nameOrdering);

            svg.append("rect")
                .attr("class", "background")
                .attr("width", width)
                .attr("height", height);

            var row = svg.selectAll(".row").data(matrix).enter()
                .append("g")
                .attr("class", "row")
                .attr("transform", function(d, i) { return "translate(0," + x(i) + ")"; })
                .each(row);

            row.append("line").attr("x2", width);

            row.append("text")
                .attr("x", -6)
                .attr("y", x.rangeBand() / 2)
                .attr("dy", ".32em")
                .attr("text-anchor", "end")
                .text(function(d, i) { return users[i].name; });

            var column = svg.selectAll(".column")
                .data(matrix)
                .enter().append("g")
                .attr("class", "column")
                .attr("transform", function(d, i) { return "translate(" + x(i) + ")rotate(-90)"; });

            column.append("line").attr("x1", -width);

            column.append("text")
                  .attr("x", 6)
                  .attr("y", x.rangeBand() / 2)
                  .attr("dy", ".32em")
                  .attr("text-anchor", "start")
                  .text(function(d, i) { return users[i].name; });

            function row(row) {
                var cell = d3.select(this).selectAll(".cell")
                    .data(row.filter(function(d) { return d.z; }))
                    .enter().append("rect")
                        .attr("class", "cell")
                        .attr("x", function(d) { return x(d.x); })
                        .attr("width", x.rangeBand())
                        .attr("height", x.rangeBand())
                        .style("fill-opacity", function(d) { return z(d.z); })
                        .on("mouseover", mouseover)
                        .on("mouseout", mouseout);
            }

            function mouseover(p) {
                d3.selectAll(".row text").classed("active", function(d, i) { return i == p.y; });
                d3.selectAll(".column text").classed("active", function(d, i) { return i == p.x; });
            }

            function mouseout() {
                d3.selectAll("text").classed("active", false);
            }
        }

        // ---------- INITIALIZATION ---------- //
        model.init();
        matrix.init();
    </script>
</body>
</html>