<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <script src="js/d3.v3.min.js"></script>
    <script src="js/generateData.js"></script>
    <script src="/socket.io/socket.io.js"></script>
    <link rel="stylesheet" type="text/css" href="css/styles.css">

    <style>
        .background {
            fill: #eee;
        }

        line {
            stroke: #fff;
        }

        text.active {
            fill: red;
        }

        *{
            font-size: 10px;
        }
    </style>
</head>
<body>
    <div id='matrix'></div>

    <script>
        // ---------- SOCKET.IO and EVENTS ---------- //
        var io = io();

        // TODO: get all other sockets and initialize model
        io.emit('observerConnect', function(data) {
            // store data in model and initialize matrix
        });

        // TODO: receive a draw event
        io.on('drawCircle', function(data) {
            console.log(data);
            // update the model
            // update the matrix
        });

        // TODO: catch new connections
        io.on('newConnection', function(conn) {
            console.log(conn);
        });


        // ---------- CLASSES ---------- //
        function User(name) {
            this.name = name;
            this.id = getUserCounter();
            this.messages = [];
            this.value = 0;
        }

        User.prototype.addMessage = function(text, timestamp) {
            this.messages.append(new Message(text, timestamp));
        };

        User.prototype.getUserCounter = function() {
            var counter = 0;
            return function() { return counter++; }
        }();

        function Message(text, timestamp) {
            this.text = text;
            this.timestamp = timestamp;
        }


        // ---------- MVC ---------- //
        var model = {
            // initializes model to hold data
            init: function(data) {
                this.allData = [];
                if (data) this.storeInModel(data);
                // holds the current data being shown in view
                this.viewModel = [];
            },

            // reads more data into model
            storeInModel: function(data) {},

            // store new data in viewModel
            storeInViewModel: function(dataSlice) {},

            getViewModel: function() { return this.viewModel; }
        };

        var controller = {
            init: function(data) {
                model.init(data);
                view.init();
            },

            //
            sliceData: function() {

            },

            // feed current viewModel into view
            renderView: function() {
                var data = model.getViewModel();
                var matrix = constructMatrix(data);
                view.render(matrix);
            }
        };

        var view = {
            // create new canvas for matrix to be drawn in
            init: function() {
                this.margin = {top: 80, right: 0, bottom: 10, left: 80};
                this.width = 480;
                this.height = 480;
            },

            // draw a new matrix
            render: function(matrix) {
                var x = d3.scale.ordinal().rangeBands([0, width]), // scale for the position of user
                    z = d3.scale.linear().clamp(true), // scale for the link strength
                    ordering; // how to order users of matrix

                // remove all previous matrix svgs and create new one
                d3.select('#matrix svg').remove();
                this.svg = d3.select('#matrix').append('svg')
                    .attr("width", this.width + this.margin.left + this.margin.right)
                    .attr("height", this.height + this.margin.top + this.margin.bottom)
                    .style("margin-left", this.margin.left + "px")
                    .append("g")
                    .attr("transform", "translate(" + this.margin.left + "," + this.margin.top + ")");

                // order by name default
                ordering = matrix.ordering ? matrix.ordering : orderByName(matrix.users);
                x.domain(ordering);
                z.domain([0, d3.max(matrix.links, function(link) { return link.value; })]);

                // draw matrix rows
                var row = svg.selectAll(".row")
                    .data(matrix.matrix).enter()
                    .append("g")
                    .attr("class", "row")
                    .attr("transform", function(d, i) { return "translate(0," + x(i) + ")"; })
                    .each(row);

                row.append("line").attr("x2", width);

                row.append("text")
                    .attr("x", -6)
                    .attr("y", x.rangeBand() / 2)
                    .attr("dy", ".32em")
                    .attr("text-anchor", "end")
                    .text(function(d, i) { return matrix.users[i].name; });

                //draw matrix columns
                var column = svg.selectAll(".column")
                    .data(matrix.matrix).enter()
                    .append("g")
                    .attr("class", "column")
                    .attr("transform", function(d, i) { return "translate(" + x(i) + ")rotate(-90)"; });

                column.append("line").attr("x1", -width);

                column.append("text")
                      .attr("x", 6)
                      .attr("y", x.rangeBand() / 2)
                      .attr("dy", ".32em")
                      .attr("text-anchor", "start")
                      .text(function(d, i) { return users[i].name; });

                // fill in matrix with data and add hover effects
                function row(row) {
                    var cell = d3.select(this).selectAll(".cell")
                        .data(row.filter(function(d) { return d.z; }))
                        .enter().append("rect")
                            .attr("class", "cell")
                            .attr("x", function(d) { return x(d.x); })
                            .attr("width", x.rangeBand())
                            .attr("height", x.rangeBand())
                            .style("fill-opacity", function(d) { return z(d.z); })
                            // .style("fill", function(d) { console.log(users[d.x]); return users[d.x].color; })
                            .on("mouseover", mouseover)
                            .on("mouseout", mouseout);
                }

                function mouseover(p) {
                    console.log(p);
                    d3.selectAll(".row text").classed("active", function(d, i) { return i == p.y; });
                    d3.selectAll(".column text").classed("active", function(d, i) { return i == p.x; });
                }

                function mouseout() {
                    d3.selectAll("text").classed("active", false);
                }
            },

            // order the elements alphabetically by name
            orderByName: function(users) {
                return d3.range(users.length).sort(function(a, b) {
                    return d3.ascending(users[a].name, users[b].name);
                });
            }
        }


        // ---------- HOLD DATA ---------- //
        var model = {
            init: function(data) {
                var that = this;
                this.users = {};
                this.links = [];
                this.color = d3.scale.category20();

                if (data) {
                    // read in the data
                    data.forEach(function(message) {
                        if (!that.getUserByName(message.name)) {
                            that.addUser(message.name);
                        }
                        var user = that.getUserByName(message.name);
                        if (user) {
                            that.addMessage(user.id, message.text, message.timestamp);

                            // assume user sends message to all users currently in room
                            var users = Object.keys(that.users);
                            var value = that.computeValue(message.text);

                            users.forEach(function(name) {
                                that.addLink(user.id, that.users[name].id, value);
                            });
                        }
                    });
                }
            },

            addUser: function(name) {
                var user = new User(name);
                user.color = this.color(Math.random());
                this.users[user.id] = user;
            },

            removeUser: function(id) {
                delete this.users.id;
            },

            getNumUsers: function() {
                var size = 0;
                for (var key in this.users) {
                    if (this.users.hasOwnProperty(key)) size++;
                }
                return size;
            },

            getUserByName: function(name) {
                for (var id in this.users) {
                    var user = this.users[id];
                    if (user.name === name) return user;
                }
                return null;
            },

            addMessage: function(id, message, timestamp) {
                try {
                    if (!this.users[id]) throw 'user id bad';
                    this.users[id].addMessage(message, timestamp);
                }
                catch (err) {
                    alert('could not add message because ' + err);
                }
            },

            addLink: function(src, target, value) {
                var value = typeof value !== 'undefined' ? value : 1;

                var link;

                // find link with src and target in links
                this.links.forEach(function(link) {
                    if (link.source === src && link.target === target) { link = link; }
                });

                if (link) {
                    link.value += value;
                } else {
                    this.links.push({source: src, target: target, value: value});
                }
            },

            computeValue: function(datum) {
                return datum.length;
            }
        }

        var matrix = {
            init: function(width) {
                width = typeof width !== 'undefined' ? width : 720;

                this.matrix = [];
                this.ordering = nameOrdering;
                this.x = d3.scale.ordinal().rangeBands([0, width]); // for the position of user
                this.z = d3.scale.linear().domain([0, 4]).clamp(true); // for the link strength, only 5 levels
                this.c = d3.scale.category10().domain(d3.range(10)); // for the cluster colors
            },

            setOrdering: function(ordering) {
                if (this.hasOwnProperty(ordering)) this.ordering = ordering;
                else console.log('ordering not found');
            },

            nameOrdering: function() {
                var obj = model.users,
                    users = Object.keys(obj).map(function(key) { return obj[key]; });

                return d3.range(this.matrix.length).sort(function(a, b) {
                    return d3.ascending(users[a].name, users[b].name);
                });
            },

            // insert new row for a user in the right location
            addUser: function(user) {
                if (!user.id in model.users) {
                    console.log('user does not exist');

                } else {
                    var ordering = this.ordering();

                    var matrix = this.matrix,
                        n = matrix.length;
                    // append new column to old rows
                    matrix.map(function(row, i) { row.push({x: n, y: i, z: 0 }); });
                    // create new row
                    matrix[n] = d3.range(n+1).map(function(j) { return {x: j, y: n, z: 0 }; });
                }
            },

            // return index corresponding to id
            getIndex: function(id) {
                matrix[0].forEach(function(col, i) {
                    if (col.id == id) return i;
                });
                return null;
            },

            // create new link or add value to existing link
            newLink: function(src, target, value) {
                var srcIndex = getIndex(src),
                    targetIndex = getIndex(target);

                if (matrix[srcIndex][targetIndex] > 0) {
                    matrix[srcIndex][targetIndex] += value;
                } else {
                    matrix[srcIndex][targetIndex] = value;
                }
            }
        }

        function createMatrix(model) {
            d3.select('#matrix svg').remove();
            var margin = {top: 80, right: 0, bottom: 10, left: 80},
                width = 480,
                height = 480;

            var svg = d3.select('#matrix').append('svg')
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
                .style("margin-left", margin.left + "px")
                .append("g")
                .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

            var x = d3.scale.ordinal().rangeBands([0, width]), // for the position of user
                z = d3.scale.linear().clamp(true); // for the link strength

            var matrix = [],
                users = model.users,
                links = model.links,
                n = model.getNumUsers();

            // initialize matrix
            for (var i=0; i<n; i++) {
                matrix[i] = d3.range(n).map(function(j) { return {x: j, y: i, z: 0}; });
            };

            links.forEach(function(link) {
                matrix[link.source][link.target].z += link.value; // bottom left triangle
                // matrix[link.target][link.source].z += link.value; // top right triangle
                // matrix[link.source][link.source].z += link.value; // node to itself
                // matrix[link.target][link.target].z += link.value; // node to itself
            })

            // ordering of the elements in the matrix
            var nameOrdering = d3.range(n).sort(function(a, b) {
                return d3.ascending(users[a].name, users[b].name);
            })

            x.domain(nameOrdering);
            z.domain([0, d3.max(links, function(link) { return link.value; })]);

            svg.append("rect")
                .attr("class", "background")
                .attr("width", width)
                .attr("height", height);

            var row = svg.selectAll(".row").data(matrix).enter()
                .append("g")
                .attr("class", "row")
                .attr("transform", function(d, i) { return "translate(0," + x(i) + ")"; })
                .each(row);

            row.append("line").attr("x2", width);

            row.append("text")
                .attr("x", -6)
                .attr("y", x.rangeBand() / 2)
                .attr("dy", ".32em")
                .attr("text-anchor", "end")
                .text(function(d, i) { return users[i].name; });

            var column = svg.selectAll(".column")
                .data(matrix)
                .enter().append("g")
                .attr("class", "column")
                .attr("transform", function(d, i) { return "translate(" + x(i) + ")rotate(-90)"; });

            column.append("line").attr("x1", -width);

            column.append("text")
                  .attr("x", 6)
                  .attr("y", x.rangeBand() / 2)
                  .attr("dy", ".32em")
                  .attr("text-anchor", "start")
                  .text(function(d, i) { return users[i].name; });

            function row(row) {
                var cell = d3.select(this).selectAll(".cell")
                    .data(row.filter(function(d) { return d.z; }))
                    .enter().append("rect")
                        .attr("class", "cell")
                        .attr("x", function(d) { return x(d.x); })
                        .attr("width", x.rangeBand())
                        .attr("height", x.rangeBand())
                        .style("fill-opacity", function(d) { return z(d.z); })
                        // .style("fill", function(d) { console.log(users[d.x]); return users[d.x].color; })
                        .on("mouseover", mouseover)
                        .on("mouseout", mouseout);
            }

            function mouseover(p) {
                console.log(p);
                d3.selectAll(".row text").classed("active", function(d, i) { return i == p.y; });
                d3.selectAll(".column text").classed("active", function(d, i) { return i == p.x; });
            }

            function mouseout() {
                d3.selectAll("text").classed("active", false);
            }
        }


        // ---------- INITIALIZATION ---------- //
        var fakeData = JSON.parse(generate.generateData());
        var padding = 100;
        var svg = d3.select('#matrix').append('svg').attr('width', 720).attr('height', 720);
        var x = d3.scale.linear().domain(d3.extent(fakeData, function(d) { return d.action.position.x; })).range([padding, 720-padding]);
        var y = d3.scale.linear().domain(d3.extent(fakeData, function(d) { return d.action.position.y; })).range([720-padding, padding]);
        var r = d3.scale.linear().domain(d3.extent(fakeData, function(d) { return d.action.text.length; })).range([0, 720]);

        svg.selectAll('circle')
           .data(fakeData).enter()
           .append('circle')
           .attr('cx', function(d) { return x(d.action.position.x); })
           .attr('cy', function(d) { return y(d.action.position.y); })
           .attr('r', function(d) { return Math.sqrt(r(d.action.text.length)); });

        // ---------- FILTERS ---------- //
        var filtering = function(){
            return {
                /**
                * param d - d3 selection of data
                * param s - start
                * param t - end
                */
                slice: function(d, s, t) {
                    return d.filter(function(a) {
                        return a.action.date >= s && a.action.date <= t;
                    });
                },

                /** TODO: not sure if storing in arrays works with D3
                * param d - d3 selection of data
                * param l - length of time block
                * param n - first n events per block (optional)
                */
                block: function(d, l, n) {
                    var blocks = [],
                        curr = [],
                        time = l,
                        d = d.sort(function(a, b) { return d3.ascending(a.action.date, b.action.date); });

                    // split data into blocks
                    d.each(function(a) {
                        if (a.action.date <= time) {
                            if (typeof n === 'undefined') curr.push(a);
                            else if (curr.length < n) curr.push(a);
                        } else {
                            blocks.push(curr);
                            // shift time block until current event fits
                            while (a.action.date > time) time += l;
                            curr = [a];
                        }
                    });
                    blocks.push(curr);
                    return blocks;
                },

            };
        }();

        var allData = d3.selectAll('circle');
        console.log(filtering.block(allData, 200000, 3));
        var blocked = filtering.block(allData, 200000, 3);

        // var filtered = filtering.slice(allData, 0, 100000);
        // console.log(allData.size(), filtered.size());
        // // filtered.attr('fill', 'red');
        // allData.data(filtered)
        //     .attr('fill','red');
        //     // .exit().remove();
        // console.log(allData.size());

        // ----------- SORTS ----------- //
        // TODO: rewrite to use d3 selections
        var sorting = function(){
            /**
            * param d - javascript array of objects
            * param p - object property
            * param asc - ascending sorting or not, true by default
            */

            var byString = function(d, p, asc) {
                var asc = typeof asc !== 'undefined' ? asc : true,
                    f = function(a, b) {
                        if (a.action[p] > b.action[p]) return asc ? 1 : -1;
                        if (a.action[p] < b.action[p]) return asc ? -1 : 1;
                        return 0;
                    };
                return d.sort(f);
            };

            return {
                byName: function(d, asc) { return byString(d, 'name', asc); },

                byLocation: function(d, asc) { return byString(d, 'location', asc); }
            }
        }();

    </script>
</body>
</html>



